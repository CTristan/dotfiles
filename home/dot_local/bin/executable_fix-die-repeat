#!/usr/bin/env bash
#
# fix-die-repeat.sh - Automated check, review, and fix loop using pi
#
# Usage: fix-die-repeat [OPTIONS]
#
# Options:
#   -c, --check-cmd CMD      Command to run checks (default: ./scripts/ci.sh)
#   -n, --max-iters N        Maximum loop iterations (default: 10)
#       --clear-artifacts    Clear existing artifacts before starting
#       --pr-review          Enable PR review mode
#   -h, --help               Show this help message
#
# Environment variables:
#   FDR_CHECK_CMD, FDR_MAX_ITERS, FDR_CLEAR_ARTIFACTS, FDR_PR_REVIEW
#

set -euo pipefail

# Defaults (can be overridden by env vars)
FDR_CHECK_CMD="${FDR_CHECK_CMD:-./scripts/ci.sh}"
FDR_MAX_ITERS="${FDR_MAX_ITERS:-10}"
FDR_CLEAR_ARTIFACTS="${FDR_CLEAR_ARTIFACTS:-0}"
FDR_PR_REVIEW="${FDR_PR_REVIEW:-0}"

# Paths
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
FDR_DIR="$PROJECT_ROOT/.fix-die-repeat"
REVIEW_FILE="$FDR_DIR/review.md"
REVIEW_CURRENT_FILE="$FDR_DIR/review_current.md"
BUILD_HISTORY_FILE="$FDR_DIR/build_history.md"
CHECKS_LOG="$FDR_DIR/checks.log"
PI_LOG="$FDR_DIR/pi.log"

iteration=0
PREV_CHECKS_HASH=""

usage() {
    echo "Usage: $(basename "$0") [OPTIONS]"
    echo ""
    echo "Options:"
    echo "  -c, --check-cmd CMD      Command to run checks (default: ./scripts/ci.sh)"
    echo "  -n, --max-iters N        Maximum loop iterations (default: 10)"
    echo "      --clear-artifacts    Clear existing artifacts before starting"
    echo "      --pr-review          Enable PR review mode"
    echo "  -h, --help               Show this help message"
    echo ""
    echo "Environment variables can also be used:"
    echo "  FDR_CHECK_CMD, FDR_MAX_ITERS, FDR_CLEAR_ARTIFACTS, FDR_PR_REVIEW"
}

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [fdr] $*"
}

error() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] [fdr] ERROR: $*" >&2
}

format_duration() {
    local total_seconds=$1
    local hours=$((total_seconds / 3600))
    local minutes=$(((total_seconds % 3600) / 60))
    local seconds=$((total_seconds % 60))

    if [[ $hours -gt 0 ]]; then
        printf "%dh %dm %ds" "$hours" "$minutes" "$seconds"
    elif [[ $minutes -gt 0 ]]; then
        printf "%dm %ds" "$minutes" "$seconds"
    else
        printf "%ds" "$seconds"
    fi
}

# Cleanup and logging on unexpected exit
cleanup() {
    local exit_code=$?
    if [[ $exit_code -ne 0 ]]; then
        error "Script exited unexpectedly with code $exit_code at iteration $iteration"
        if [[ -f "$PI_LOG" ]] && [[ -s "$PI_LOG" ]]; then
            error "=== Last 30 lines of pi.log ==="
            tail -30 "$PI_LOG" >&2
            error "=== End of pi.log excerpt ==="
        fi
    fi
}
trap cleanup EXIT

# Fetch PR threads and format them for the agent
fetch_pr_threads() {
    local branch
    branch=$(git branch --show-current)

    if [[ -z "$branch" ]]; then
        error "Not on a git branch. Skipping PR review."
        return 0
    fi

    log "Fetching PR info for branch: $branch"

    # Check gh auth
    if ! gh auth status >/dev/null 2>&1; then
        error "GitHub CLI not authenticated. Skipping PR review."
        return 0
    fi

    # Get PR info
    local pr_json
    if ! pr_json=$(gh pr view "$branch" --json number,url,headRepository,headRepositoryOwner 2>/dev/null); then
        log "No open PR found for $branch or error fetching PR. Skipping PR review."
        return 0
    fi

    local pr_number pr_url repo_owner repo_name
    pr_number=$(echo "$pr_json" | jq -r .number)
    pr_url=$(echo "$pr_json" | jq -r .url)
    repo_owner=$(echo "$pr_json" | jq -r .headRepositoryOwner.login)
    repo_name=$(echo "$pr_json" | jq -r .headRepository.name)

    log "Found PR #$pr_number ($pr_url). Fetching threads..."

    # GraphQL query to get unresolved threads
    local query='
      query($owner: String!, $repo: String!, $number: Int!) {
        repository(owner: $owner, name: $repo) {
          pullRequest(number: $number) {
            reviewThreads(first: 100) {
              nodes {
                isResolved
                id
                path
                line
                comments(first: 10) {
                  nodes {
                    author { login }
                    body
                  }
                }
              }
            }
          }
        }
      }
    '

    local gql_result
    if ! gql_result=$(gh api graphql -f query="$query" -F owner="$repo_owner" -F repo="$repo_name" -F number="$pr_number"); then
        error "Failed to fetch threads via GraphQL."
        return 0
    fi

    # Parse and format threads using jq
    # We filter for !isResolved and format the output
    local threads_output
    threads_output=$(echo "$gql_result" | jq -r '
        .data.repository.pullRequest.reviewThreads.nodes
        | map(select(.isResolved == false))
        | to_entries
        | map(
            "--- Thread #\(.key + 1) ---\n" +
            "ID: \(.value.id)\n" +
            "File: \(.value.path)\n" +
            (if .value.line then "Line: \(.value.line)\n" else "" end) +
            (.value.comments.nodes | map("[\(.author.login // "unknown")]: \(.body)") | join("\n")) +
            "\n"
          )
        | join("\n")
    ')

    if [[ -n "$threads_output" ]]; then
        local count
        count=$(echo "$gql_result" | jq '[.data.repository.pullRequest.reviewThreads.nodes[] | select(.isResolved == false)] | length')

        {
            echo "I've found $count unresolved review threads on PR #$pr_number ($pr_url)."
            echo ""
            echo "Please review each thread, check the associated code, and determine if a fix is required."
            echo "If a fix is needed, apply it. If not, explain why."
            echo ""
            echo "CRITICAL: For each thread below, the 'ID' is the GraphQL thread ID. You MUST use this ID with the available tools:"
            echo " - To resolve a thread after fixing: use 'resolve_pr_threads(threadIds: [\"ID_HERE\"])'"
            echo " - To reply to a thread (e.g. to explain a 'won't fix'): use 'reply_to_thread(threadId: \"ID_HERE\", body: \"...\")'"
            echo ""
            echo "$threads_output"
        } > "$REVIEW_CURRENT_FILE"

        log "Found $count unresolved threads. Added to review queue."
        return 0
    else
        log "No unresolved threads found."
        return 0
    fi
}

# Run pi with logging - captures exit code and logs failures
run_pi() {
    local exit_code=0
    # Run pi, capturing stderr to log file while still showing stdout
    if ! pi "$@" 2> >(tee -a "$PI_LOG" >&2); then
        exit_code=$?
        error "pi exited with code $exit_code"
        error "pi stderr logged to: $PI_LOG"
        if [[ -f "$PI_LOG" ]]; then
            error "Last 20 lines of pi.log:"
            tail -20 "$PI_LOG" >&2
        fi
        return $exit_code
    fi
    return 0
}

get_changed_files() {
    # Get both staged and unstaged changed files, deduplicate, filter to existing files only
    {
        git diff --name-only 2>/dev/null || true
        git diff --cached --name-only 2>/dev/null || true
    } | sort -u | while IFS= read -r file; do
        # Only include files that exist (exclude deleted files and .fix-die-repeat directory)
        if [[ -f "$PROJECT_ROOT/$file" ]] && [[ "$file" != .fix-die-repeat/* ]]; then
            echo "$file"
        fi
    done
}

append_review_entry() {
    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    {
        echo "## Iteration $iteration - Review ($timestamp)"
        if [[ -s "$REVIEW_CURRENT_FILE" ]]; then
            cat "$REVIEW_CURRENT_FILE"
        else
            echo "_No issues found._"
        fi
        echo
    } >> "$REVIEW_FILE"
}

append_resolution_entry() {
    local message="$1"
    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    {
        echo "### Iteration $iteration - Resolution ($timestamp)"
        echo "- $message"
        echo
    } >> "$REVIEW_FILE"
}

main() {
    # Argument parsing
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -c|--check-cmd)
                if [[ -n "${2:-}" && ! "$2" =~ ^- ]]; then
                    FDR_CHECK_CMD="$2"
                    shift 2
                else
                    error "Argument for $1 is missing"
                    usage
                    exit 1
                fi
                ;;
            -n|--max-iters)
                if [[ -n "${2:-}" && ! "$2" =~ ^- ]]; then
                    FDR_MAX_ITERS="$2"
                    shift 2
                else
                    error "Argument for $1 is missing"
                    usage
                    exit 1
                fi
                ;;
            --clear-artifacts)
                FDR_CLEAR_ARTIFACTS=1
                shift
                ;;
            --pr-review)
                FDR_PR_REVIEW=1
                shift
                ;;
            -h|--help)
                usage
                exit 0
                ;;
            *)
                error "Unknown option: $1"
                usage
                exit 1
                ;;
        esac
    done

    cd "$PROJECT_ROOT"

    # Ensure .fix-die-repeat directory exists
    mkdir -p "$FDR_DIR"

    if [[ "$FDR_CLEAR_ARTIFACTS" == "1" || "$FDR_CLEAR_ARTIFACTS" == "true" ]]; then
        log "Clearing existing .log and .md artifacts in $FDR_DIR"
        find "$FDR_DIR" -mindepth 1 -maxdepth 1 -type f \( -name "*.log" -o -name "*.md" \) -exec rm -f -- {} +
    fi

    # Clear pi.log at start of run
    > "$PI_LOG"
    log "Logging pi stderr to: $PI_LOG"

    while true; do
        iteration=$((iteration + 1))
        log "===== Iteration $iteration of $FDR_MAX_ITERS ====="

        if [[ $iteration -gt $FDR_MAX_ITERS ]]; then
            error "Maximum iterations ($FDR_MAX_ITERS) exceeded. Could not resolve all issues."
            exit 1
        fi

        # Step 1: Run checks
        log "[Step 1] Running ${FDR_CHECK_CMD} (output: checks.log)..."
        checks_start_time=$(date +%s)
        if ${FDR_CHECK_CMD} > "$CHECKS_LOG" 2>&1; then
            checks_status=0
        else
            checks_status=$?
        fi
        checks_end_time=$(date +%s)
        checks_duration=$((checks_end_time - checks_start_time))
        log "[Step 1] run_checks duration: $(format_duration "$checks_duration")"

        # Check for repeated failures to prevent loops
        current_checks_hash=$(git hash-object "$CHECKS_LOG" 2>/dev/null || echo "iteration_$iteration")
        repeated_failure_warning=""

        if [[ "$checks_status" -ne 0 ]]; then
             if [[ "$current_checks_hash" == "$PREV_CHECKS_HASH" ]]; then
                 repeated_failure_warning="WARNING: The check output is IDENTICAL to the previous iteration. Your last fix did NOT work. You must try a DIFFERENT approach."
                 log "Detected identical check output. Adding warning to prompt."
             fi
        fi
        PREV_CHECKS_HASH="$current_checks_hash"

        if [[ $checks_status -eq 0 ]]; then
            log "[Step 2B] Checks passed. Proceeding to review."
        else
            log "[Step 2A] Checks failed. Running pi to fix errors..."

            # Collect files to context
            changed_files=()
            while IFS= read -r line; do
                [[ -n "$line" ]] && changed_files+=("$line")
            done < <(get_changed_files)

            # Construct args for fix step
            fix_checks_args=("-p" "@$CHECKS_LOG")
            if [[ -f "$REVIEW_FILE" ]]; then
                fix_checks_args+=("@$REVIEW_FILE")
            fi
            if [[ -f "$BUILD_HISTORY_FILE" ]]; then
                fix_checks_args+=("@$BUILD_HISTORY_FILE")
            fi
            for f in "${changed_files[@]}"; do
                fix_checks_args+=("@$f")
            done

            # Construct prompt for fix step
            fix_checks_prompt="The file .fix-die-repeat/checks.log contains the failure output from ${FDR_CHECK_CMD}. "
            if [[ -n "$repeated_failure_warning" ]]; then
                fix_checks_prompt+="$repeated_failure_warning "
            fi
            if [[ -f "$REVIEW_FILE" ]]; then
                 fix_checks_prompt+="I have attached .fix-die-repeat/review.md which contains history of previous iterations. Review it to avoid repeating mistakes. "
            fi
            if [[ -f "$BUILD_HISTORY_FILE" ]]; then
                 fix_checks_prompt+="I have attached .fix-die-repeat/build_history.md which contains a summary of files you modified in previous attempts to fix the build. Use this to avoid repeating ineffective changes. "
            fi
            fix_checks_prompt+="I have also attached the currently changed files for context. "
            fix_checks_prompt+="Your goal is to FIX the errors. Follow this plan:\n1. ANALYZE the log and identify the root cause.\n2. PLAN your fix.\n3. APPLY the fix using 'edit'.\n4. VERIFY the fix by running the relevant command locally (using 'bash').\nDo not exit until you have verified the fix works."

            run_pi "${fix_checks_args[@]}" "$fix_checks_prompt"

            # Record history
            {
                echo "## Iteration $iteration Fixes"
                git diff --stat
                echo ""
            } >> "$BUILD_HISTORY_FILE"

            continue
        fi

        # Step 3: Prepare review artifacts
        log "[Step 3] Preparing review artifacts..."
        if [[ ! -f "$REVIEW_FILE" ]]; then
            touch "$REVIEW_FILE"
        fi
        if [[ -f "$REVIEW_CURRENT_FILE" ]]; then
            rm "$REVIEW_CURRENT_FILE"
        fi

        # Step 3.5: Check PR threads if enabled
        if [[ "$FDR_PR_REVIEW" == "1" ]]; then
            log "[Step 3.5] Checking for unresolved PR threads..."
            fetch_pr_threads
            # Disable PR review for subsequent iterations
            FDR_PR_REVIEW=0
        fi

        # Skip local review if we have PR threads to process
        if [[ -s "$REVIEW_CURRENT_FILE" ]]; then
            log "[Step 4] Using PR threads from $REVIEW_CURRENT_FILE for review."
            log "[Step 5] Skipping local file review generation."
        else
            # Step 4: Collect files
            log "[Step 4] Collecting changed and staged files..."
            changed_files=()
            while IFS= read -r line; do
                [[ -n "$line" ]] && changed_files+=("$line")
            done < <(get_changed_files)

            if [[ ${#changed_files[@]} -eq 0 ]]; then
                error "No changed or staged files found. Nothing to review."
                exit 1
            fi

            log "[Step 4] Found ${#changed_files[@]} file(s) to review"

            # Step 5: Run pi review
            log "[Step 5] Running pi to review files..."
            pi_args=("-p")
            for f in "${changed_files[@]}"; do
                pi_args+=("@$f")
            done
            if [[ -f "$REVIEW_FILE" ]]; then
                pi_args+=("@$REVIEW_FILE")
            fi

            run_pi "${pi_args[@]}" "Review all of the provided files for issues. Use .fix-die-repeat/review.md as historical context.
Your task is ONLY to identify and document issues. Do NOT fix them yourself.

Classify issues as:
- [CRITICAL]: Bugs, security flaws, compilation errors, broken logic.
- [NIT]: Style issues, minor optimizations, comments, formatting.

IMPORTANT:
1. ONLY report [NIT] issues if you also find [CRITICAL] issues.
2. If you only find [NIT] issues, report 'No critical issues found' and create an empty .fix-die-repeat/review_current.md.
3. If you find [CRITICAL] issues, report BOTH [CRITICAL] and [NIT] issues.

If you find reportable issues, use the 'write' tool to save them to '.fix-die-repeat/review_current.md' in the project root.
If you find NO reportable issues, use the 'write' tool to create an empty file named '.fix-die-repeat/review_current.md' in the project root."
        fi

        append_review_entry

        # Step 6: Analyze review results
        if [[ ! -f "$REVIEW_CURRENT_FILE" ]]; then
            error ".fix-die-repeat/review_current.md was not created by pi. This is unexpected."
            exit 1
        fi

        if [[ -s "$REVIEW_CURRENT_FILE" ]]; then
            log "[Step 6A] Issues found in .fix-die-repeat/review_current.md. Running pi to fix them..."

            fix_args=("-p" "@$REVIEW_CURRENT_FILE")
            if [[ -f "$REVIEW_FILE" ]]; then
                fix_args+=("@$REVIEW_FILE")
            fi

            run_pi "${fix_args[@]}" "Fix all issues documented in .fix-die-repeat/review_current.md. Address each issue mentioned in the file.

Follow this plan:
1. READ the issues in .fix-die-repeat/review_current.md.
2. PLAN your fixes.
3. If an issue is a logic bug, CREATE a unit test to prevent regression.
4. APPLY the fixes using 'edit'.
5. VERIFY the fixes. Run ${FDR_CHECK_CMD} (or relevant tests) to ensure your changes didn't break the build and new tests pass.

Ensure that your changes do not re-surface older issues listed in .fix-die-repeat/review.md.
If these issues are PR threads (indicated by 'Thread #ID'), use the 'resolve_pr_threads' tool to mark them resolved on GitHub ONLY after verifying the fix."
            append_resolution_entry "Fixes applied for .fix-die-repeat/review_current.md; verification pending."
            continue
        else
        log "[Step 6B] No issues found in .fix-die-repeat/review_current.md."
            append_resolution_entry "No issues found."
        fi

        # Step 7: Done
        if [[ -f "$REVIEW_CURRENT_FILE" ]]; then
            rm "$REVIEW_CURRENT_FILE"
        fi
        log "[Step 7] Done! All checks passed and no review issues found. .fix-die-repeat/review.md retained."
        exit 0
    done
}

main "$@"
